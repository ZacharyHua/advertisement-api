#!/usr/bin/env python2
# -*- coding:utf-8 -*-
# description: generate protocol buffer classes and dubbo interface for littlec server
# author: wanghuizhou
# revisor:yangli
# last modify:20180109
# version: v1.0.0

import os
import sys
import stat
import platform
from git import *
import time
import getpass
import re
import linecache

from subprocess import Popen, PIPE

reload(sys)
sys.setdefaultencoding("utf-8")

advertisement_project_info = '''/*
 * Project: littlec-api
 *
 * File Created at COMMIT_DATE
 *
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * ZYHY Company. ("Confidential Information").  You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license.
 */'''

advertisement_class_info = '''/**
 * @Type SERVICE_NAME
 * @Desc CLASS_DESCRIPTION
 * @author COMMIT_USER
 * @date COMMIT_TIME
 * @version
 */'''

advertisement_method_info = '''    /**
     * METHOD_DESCRIPTION
     *
     * @param REQUEST_NAME the REQUEST_TYPE
     * @return METHOD_RESPONSE
     */'''

advertisement_end_info = '''/**
 * Revision history
 * -------------------------------------------------------------------------
 *
 * Date Author Note
 * -------------------------------------------------------------------------
 * COMMIT_DATE COMMIT_USER create
 */'''


# Get python script path
def cur_file_dir():
    path = os.getcwd()
    if os.path.isdir(path):
        return path
    elif os.path.isfile(path):
        return os.path.dirname(path)

time_format = "%Y-%m-%d %H:%M:%S"
date_format = "%Y-%m-%d"
gen_grpc = True
gen_dubbo_interface = True

proto_exe_relative_path = os.path.sep + "executor" + os.path.sep + "protoc"
grpc_plugin_relative_path = os.path.sep + "executor" + os.path.sep + "grpc" + os.path.sep + "java" + os.path.sep + "protoc-gen-grpc-java-1.18.0-"

python_dir = cur_file_dir()
advertisement_parent_dir = os.path.dirname(python_dir)
advertisement_connector_dir = os.path.join(advertisement_parent_dir, "advertisement-connector")
#  advertisement_connector_dir = python_dir

grpc_out_dir = advertisement_connector_dir + os.path.sep + "src" + os.path.sep + "main" + os.path.sep + "java"
proto_dir = python_dir + os.path.sep + "proto"
proto_java_dir = python_dir + os.path.sep + "src" + os.path.sep + "main" + os.path.sep + "java"
java_interface_dir = proto_java_dir + os.path.sep + "com" + os.path.sep + "advertisement" + os.path.sep + "api"
proto_common_dir = proto_dir + os.path.sep + "common"
proto_inner_dir = proto_dir + os.path.sep + "inner"
proto_outer_dir = proto_dir + os.path.sep + "outer"

repo = Repo(python_dir, GitCmdObjectDB, True)


# Genrate java class

def exe_command(command):
    p = Popen(command, shell=True, stdout=PIPE, stderr=PIPE)
    print p.communicate()
    p.wait()
    if p.returncode != 0:
        clean_and_exit(1)
    print "Generate protobuf code successed!"


def clean_and_exit(exit_code):
    # delete needless file generated by pysvn
    # readme_file = python_dir + os.path.sep + "README.txt"
    # servers_file = python_dir + os.path.sep + "servers"
    # config_file = python_dir + os.path.sep + "config"
    # auth_dir = python_dir + os.path.sep + "auth"
    # if os.path.isfile(readme_file):
    #     os.remove(readme_file)
    # if os.path.isfile(servers_file):
    #     os.remove(servers_file)
    # if os.path.isfile(config_file):
    #     os.remove(config_file)
    # if os.path.exists(auth_dir):
    #     rm_dir(auth_dir)
    # exit
    exit(exit_code)


# Find .proto files in dir, exclude grpc.proto file
def work_dir(dir, topDown=True):
    proto_files = []
    for root, dirs, files in os.walk(dir, topDown):
        for name in files:
            file_path = os.path.join(root, name)
            extension = os.path.splitext(file_path)[1]
            if extension == ".proto":
                proto_files.append(file_path)
    return proto_files


# remove dir
def rm_dir(needless_dir):
    for root, dirs, files in os.walk(needless_dir, topdown=False):
        for name in files:
            os.remove(os.path.join(root, name))
        for name in dirs:
            os.rmdir(os.path.join(root, name))
    os.rmdir(needless_dir)


# Get protoc executor path according to os
def get_platform_pbexe_path():
    sysstr = platform.system()
    if sysstr == "Windows":
        return "windows-x86_64"
    elif sysstr == "Linux":
        return "linux-x86_64"
    elif sysstr == "Darwin":
        return "osx-x86_64"
    print "Error: Only support Windows/Linux/Darwin"
    clean_and_exit(1)


#  get code content
def get_code_content(code_raw):
    code_content = re.sub(r"(/\*.+?\*/)", '', code_raw)
    return code_content


# get commit information
def get_commit_info(proto_file):
    commit_info = {}
    commit_author = getpass.getuser()
    commit_time = time.strftime(time_format, time.localtime())
    commit_date = time.strftime(date_format, time.localtime())
    commits = repo.iter_commits(max_count=1, paths=proto_file)
    for commit in commits:
        commit_author = commit.author.name
        commit_time = time.strftime(time_format, time.localtime(commit.committed_date))
        commit_date = time.strftime(date_format, time.localtime(commit.committed_date))
    commit_info["commit_author"] = str(commit_author)
    commit_info["commit_time"] = str(commit_time)
    commit_info["commit_date"] = str(commit_date)

    return commit_info


# generate interafce implementation
def gen_interface_impl(inout_path, output_package, proto_file):
    proto_file_name = os.path.basename(proto_file)

    commit_info = get_commit_info(proto_file)
    #  proto_code_raw = open(proto_file, 'r').read()
    #  proto_code_content = get_code_content(proto_code_raw)
    proto_code_content = open(proto_file, 'r').read()

    # get service information
    proto_service_list = re.findall(r"^service\s*(\w+)\s*{?\s*$", proto_code_content, re.M)
    if len(proto_service_list) == 0:
        print "No need to generate interface for " + proto_file
        return
    elif len(proto_service_list) != 1:
        print "There are too many service definition in " + proto_file + "!"
        return
    proto_service = proto_service_list[0]

    # get java_package_name information
    java_package_name_list = re.findall(r'^option\s+java_package\s*=\s*"(\w|.+)"\s*;', proto_code_content, re.M)
    if len(java_package_name_list) != 1:
        print "Please check java_package information in " + proto_file + "!"
        return
    java_package_name = java_package_name_list[0]

    # get java_outer_classname information
    java_outer_classname_list = re.findall(r'^option\s+java_outer_classname\s*=\s*"(\w+)"\s*;', proto_code_content, re.M)
    java_outer_classname = ""
    if len(java_outer_classname_list) == 0:
        proto_file_short_name = os.path.splitext(proto_file_name)[0]
        java_outer_classname=proto_file_short_name[0].upper() + proto_file_short_name[1:]
    elif len(java_outer_classname_list) == 1:
        java_outer_classname=java_outer_classname_list[0]
    else:
        print "Please check java_outer_classname information in " + proto_file + "!"
        return

    # if generate multiple files?
    java_multiple_files_list = re.findall(r'^option\s+java_multiple_files\s*=\s*"(\w+)"\s*;', proto_code_content, re.M)
    java_multiple_files = False

    if len(java_multiple_files_list) == 0:
        pass
    elif len(java_multiple_files_list) == 1:
        if cmp(java_multiple_files_list[0][0], "true") == 0:
            java_multiple_files = True
    else:
        print "Please check java_multiple_files information in " + proto_file + "!"
        return

    if not java_multiple_files:
        java_package_name = java_package_name + "." + java_outer_classname

    # Get service description and method description
    proto_lines = linecache.getlines(proto_file)
    index = 0
    lines = len(proto_lines)
    service_info = []
    service_info.append(proto_service)
    method_info = {}
    method_request_response_type = []
    while index < lines:
        # get service information
        proto_service_list = re.findall(r"^service\s*(\w+)\s*{?\s*$", proto_lines[index])
        if len(proto_service_list) == 1:
            proto_service_describe_list=re.findall(r"^\s*//\s*(.+)\s*$", proto_lines[index - 1])
            if len(proto_service_describe_list) == 1:
                service_info.append(proto_service_describe_list[0])
            else:
                service_info.append("The " + proto_service_list[0])
            index += 1
            continue

        # get method information
        java_method_list = re.findall(r"^\s*rpc\s+(\w+)\s*\((\w|.+)\)\s+returns\s*\((\w|.+)\)\s*;\s*$", proto_lines[index])
        if len(java_method_list) == 1:
            java_method_info = list(java_method_list[0])
            java_method_name = java_method_info[0][0].lower() +java_method_info[0][1:]
            proto_method_descript_list=re.findall(r"^\s*//\s*(.+)\s*$", proto_lines[index - 1])
            if len(proto_method_descript_list) == 1:
                java_method_info.append(proto_method_descript_list[0])
            else:
                java_method_info.append("The " + java_method_name)
            method_info[java_method_name] = java_method_info
            method_request_response_type.append(java_method_info[1])
            method_request_response_type.append(java_method_info[2])
            index += 1
            continue
        index += 1

    # delete repeated type and sort list
    java_import_type = sorted(list(set(method_request_response_type)))

    # wb for different os
    f = open(inout_path + os.path.sep + proto_service + ".java", "wb")

    # write multithread project information
    advertisement_project_info_w = advertisement_project_info.replace("COMMIT_DATE", commit_info["commit_date"])
    f.write(advertisement_project_info_w)
    f.write("\n")

    # write multithread package information
    f.write("package " + output_package + ";\n")
    f.write("\n")

    # write import classes
    for java_import_type_w in java_import_type:
        f.write("import " + java_package_name + "." + java_import_type_w + ";\n")
    f.write("\n")
    advertisement_class_info_w = advertisement_class_info.replace("SERVICE_NAME", service_info[0] + ".java").replace("CLASS_DESCRIPTION", service_info[1]).replace("COMMIT_USER", commit_info["commit_author"]).replace("COMMIT_TIME", commit_info["commit_time"])
    f.write(advertisement_class_info_w)
    f.write("\n")

    # write interface name
    f.write("public interface " + service_info[0] + " {\n")

    # write method information
    for method_name_w, method_info_w in method_info.iteritems():
        method_request_name_w = method_info_w[1][0].lower() + method_info_w[1][1:]
        advertisement_method_info_w = advertisement_method_info.replace("METHOD_DESCRIPTION", method_info_w[3]).replace("REQUEST_TYPE", method_info_w[1]).replace("METHOD_RESPONSE", method_info_w[2]).replace("REQUEST_NAME", method_request_name_w)
        method_w = method_info_w[2] + " " + method_name_w + "(" + method_info_w[1] + " " + method_request_name_w + ");\n"
        f.write("\n" + advertisement_method_info_w + "\n")
        f.write(" " * 4 + method_w)

    # end of interface
    f.write("\n}\n")

    # write multithread end information
    advertisement_end_info_w = advertisement_end_info.replace("COMMIT_DATE", commit_info["commit_date"]).replace("COMMIT_USER", commit_info["commit_author"])
    f.write("\n")
    f.write(advertisement_end_info_w)
    f.write("\n")


# generate interafce
def gen_interface(inout, proto_files):
    if not gen_dubbo_interface:
        return
    inout_path = java_interface_dir + os.path.sep + inout
    output_package = "com.advertisement.api." + inout
    if not os.path.exists(inout_path):
        os.makedirs(inout_path)
    for proto_file in proto_files:
        gen_interface_impl(inout_path, output_package, proto_file)


def gen_proto():
    pbexe_path = get_platform_pbexe_path()
    protobuf_exe = python_dir + proto_exe_relative_path + os.path.sep + pbexe_path + os.path.sep + "bin" + os.path.sep + "protoc"
    grpc_plugin_exe = python_dir + grpc_plugin_relative_path + pbexe_path + ".exe"
    sysstr = platform.system()
    if sysstr != "Windows":
        os.environ["LD_LIBRARY_PATH"] = "/usr/local/glibc-2.14/lib:$LD_LIBRARY_PATH"
        os.chmod(protobuf_exe, stat.S_IRWXU | stat.S_IRWXG)
        os.chmod(grpc_plugin_exe, stat.S_IRWXU | stat.S_IRWXG)
    print
    print "*******************************************************"
    print "*   Generating protocol buffer files for common...    *"
    print "*******************************************************"
    proto_files = work_dir(proto_common_dir)
    protobuf_args = "-I=" + proto_dir + " " + "--java_out=" + proto_java_dir
    command = protobuf_exe + " " + protobuf_args + " " + " ".join(proto_files)
    print "Command: " + command
    exe_command(command)

    print
    print "*******************************************************"
    print "*   Generating protocol buffer files for outer...     *"
    print "*******************************************************"
    proto_files = work_dir(proto_outer_dir)
#     proto_files.remove(proto_outer_dir + os.path.sep + "grpc.proto")
    protobuf_args = "-I=" + proto_dir + " " + "--java_out=" + proto_java_dir
    command = protobuf_exe + " " + protobuf_args + " " + " ".join(proto_files)
    print "Command: " + command
    exe_command(command)
#     proto_files.remove(proto_outer_dir + os.path.sep + "connector.proto")
    gen_interface("outer", proto_files)

    print
    print "*******************************************************"
    print "*   Generating protocol buffer files for inner...     *"
    print "*******************************************************"
    print proto_inner_dir
    proto_files = work_dir(proto_inner_dir)
    print proto_files
    protobuf_args = "-I" + proto_dir + " " + "--java_out=" + proto_java_dir
    command = protobuf_exe + " " + protobuf_args + " " + " ".join(proto_files)
    print "Command: " + command
    exe_command(command)
    # 屏蔽inner/connector.proto的代码自动生成功能，ugly coding
#     proto_files.remove(proto_inner_dir + os.path.sep + "connector.proto")
    # 屏蔽inner/websocket.proto的代码自动生成功能，ugly coding
#     proto_files.remove(proto_inner_dir + os.path.sep + "websocket.proto")
    # 屏蔽inner/wsconnector.proto的代码自动生成功能，ugly coding
#     proto_files.remove(proto_inner_dir + os.path.sep + "wsconnector.proto")
    # 屏蔽inner/odasrpc.proto的代码自动生成功能，ugly coding
#     proto_files.remove(proto_inner_dir + os.path.sep + "odasrpc.proto")
    gen_interface("inner", proto_files)

    # 仅在connector服务中需要生成grpc service
    if gen_grpc:
        print
        print "*******************************************************"
        print "*   Generating grpc service for connection manager... *"
        print "*******************************************************"
        proto_files = proto_outer_dir + os.path.sep + "grpc.proto"
        protobuf_args = "-I=" + proto_dir + " " + "--plugin=protoc-gen-grpc-java=" + grpc_plugin_exe + " --grpc-java_out=" + proto_java_dir + " " + "--java_out=" + proto_java_dir
        command = protobuf_exe + " " + protobuf_args + " " + proto_files
        print "Command: " + command
        exe_command(command)


def main():
    gen_proto()
    clean_and_exit(0)

if __name__ == '__main__':
    main()
